## 12. 과제

<aside>
🚢

지난 강의에서 아키텍처의 큰 그림을 잡았다면,
이번 과제는 **“DB를 어떻게 설계하고, 트랜잭션을 어디까지 끊어야 하며, 정합성은 어떻게 보장할 것인가?”**를 집중적으로 다룹니다.

</aside>

### `필수 과제 **- Integration`**

- Infrastructure Layer 작성 (**“외부 세계와 연결된 모든 것”을 담당하는 계층**)
    - 예시
        - **Spring(Java) 프로젝트 예시 -  infrastructure는 구현체 (Adapter)**
            
            ```java
            📂 com.example.orderapp
             ┣ 📂 domain
             ┃ ┣ 📂 order
             ┃ ┃ ┣ 📄 Order.java
             ┃ ┃ ┣ 📄 OrderRepository.java     <-- Domain Layer
             ┃ ┣ 📂 product
             ┃ ┃ ┣ 📄 Product.java
             ┃ ┃ ┣ 📄 ProductRepository.java   <-- Domain Layer
             ┣ 📂 application
             ┃ ┣ 📂 order
             ┃ ┃ ┣ 📄 OrderService.java        <-- Use Case
             ┃ ┃ ┣ 📄 OrderCommand.java
             ┣ 📂 infrastructure
             ┃ ┣ 📂 persistence
             ┃ ┃ ┣ 📂 order
             ┃ ┃ ┃ ┣ 📄 OrderRepositoryImpl.java    <-- 실제 JPA 구현체
             ┃ ┃ ┣ 📂 product
             ┃ ┃ ┃ ┣ 📄 ProductRepositoryImpl.java
             ┃ ┣ 📂 external
             ┃ ┃ ┣ 📄 MessageQueueProducer.java     <-- MQ, 외부 연동
             ┃ ┃ ┣ 📄 NaverApiClient.java
             ┃ ┣ 📂 configuration
             ┃ ┃ ┣ 📄 RedisConfig.java
             ┃ ┃ ┣ 📄 JpaConfig.java
             ┣ 📂 api
             ┃ ┣ 📄 OrderController.java           <-- Controller Layer
            ```
            
        - **NestJS(TypeScript) 프로젝트 예시 - infrastructure: Adapter (DB, MQ, 외부 API 등)**
            
            ```tsx
            📦 src
             ┣ 📂 domain
             ┃ ┣ 📂 order
             ┃ ┃ ┣ 📄 order.entity.ts
             ┃ ┃ ┣ 📄 order.repository.ts           <-- 인터페이스
             ┃ ┣ 📂 product
             ┃ ┃ ┣ 📄 product.entity.ts
             ┃ ┃ ┣ 📄 product.repository.ts
             ┣ 📂 application
             ┃ ┣ 📂 order
             ┃ ┃ ┣ 📄 order.service.ts             <-- 유즈케이스
             ┃ ┃ ┣ 📄 dto/
             ┣ 📂 infrastructure
             ┃ ┣ 📂 persistence
             ┃ ┃ ┣ 📂 order
             ┃ ┃ ┃ ┣ 📄 order.repository.impl.ts   <-- 실제 구현체 (TypeORM 등)
             ┃ ┃ ┣ 📂 product
             ┃ ┃ ┃ ┣ 📄 product.repository.impl.ts
             ┃ ┣ 📂 external
             ┃ ┃ ┣ 📄 message-queue.producer.ts
             ┃ ┃ ┣ 📄 naver-api.client.ts
             ┃ ┣ 📂 configuration
             ┃ ┃ ┣ 📄 redis.config.ts
             ┃ ┃ ┣ 📄 typeorm.config.ts
             ┣ 📂 interfaces
             ┃ ┣ 📂 controllers
             ┃ ┃ ┣ 📄 order.controller.ts         <-- API 계층
             ┃ ┣ 📂 dto
             ┃ ┃ ┣ 📄 create-order.dto.ts
            ```
            
- 기능별 통합 테스트 작성
- Testcontainers(Optional) 또는 테스트 전용 DB로 테스트 가능하도록 구성
- **e-커머스 상품 주문 서비스**
    
    **1. Infrastructure Layer 구현**
    
    - UserBalanceRepository, ProductRepository, OrderRepository, CouponRepository 등 도메인 기반 리포지토리 구현
    - 외부 메시지 전송 기능은 **Kafka 대신 MockMessageProducer 또는 Outbox 테이블 방식으로 구현**
    - 외부 API/Fake Producer 등은 의존성 주입 형태로 설계하여 테스트 가능하도록 구성
        - 예: 주문이 완료되었을 때
        → 데이터 플랫폼(외부 시스템)에 주문 정보를 실시간 전송해야 한다
    
    **2. 기능별 통합 테스트 작성**
    
    - 충전 API → 주문 API까지 잔액 변경 테스트 포함
    - 상품 주문 & 결제 흐름 전체 통합 테스트
        - 주문 → 재고 차감 → 잔액 차감 → 주문 저장 → 외부 전송 Mock 검증
    - 외부 메시지 전송 실패 시 fallback 처리 검증 (e.g. Outbox 저장 여부 확인)
    - **결제 API는 idempotency_key 사용** → 중복 요청 테스트 포함
    - 쿠폰 발급 경쟁 조건 테스트: 동시에 요청 시 한 명만 성공


- **콘서트 예약 서비스**
    
    **1. Infrastructure Layer 구현**
    
    - ReservationTokenRepository, SeatReservationRepository, UserBalanceRepository, PaymentRepository 등 구현
    - 임시 좌석 배정: **Redis 없이도 상태 컬럼 + 만료 시간 방식으로 구현 가능**
    - 대기열 토큰 관리: Redis 또는 DB 기반으로 구현
    
    **2. 기능별 통합 테스트 작성**
    
    - 유저가 토큰을 발급받고 → 좌석 예약 요청 → 결제 완료까지의 흐름 테스트
    - 만료 시간 도래 후 좌석이 다시 예약 가능한지 확인
    - 다중 유저가 동시에 좌석 요청 시 한 명만 성공하도록 테스트 구성

> `Infrastructure` 는 RDMBS ( MySQL ) 기반으로 작성합니다.
> 



### **`(선택)심화 과제 - DB`**

- 조회가 오래 걸릴 수 있는 기능을 리스트업하고 분석하여, 테이블 재설계 / 인덱스 등 솔루션을 도출하는 내용의 보고서 작성
- 주요 기능별 동시성 테스트 작성

> 이번 과제에서 동시성 테스트는 성공하는 것이 목적이 아니라, 어떤 기능에 대해 동시성 이슈가 예민할지를 미리 리스트업하고 작성하여 Rule 로 가두는 것을 목적으로 합니다.
>