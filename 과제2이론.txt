<aside>

## 목차

</aside>

## 들어가기에 앞서

### TDD Chapter 정리

<aside>
💡

테스트가 중요하다라는 것을 인지하는것이 중요합니다.

</aside>

- 여러분은 왜 TDD 가 중요하다고 생각했나요?
    - 여러분은 TDD가 왜 궁금했나요? 아마 테스트를 검색하면 가장 많이 나오는것이 TDD이기 때문일것입니다.(키워드로 유닛테스트, TDD가 가장 많이 나오죠)
    - 학습을 위해 가장 먼저 떠올리는 것이 키워드이고, TDD가 중요하다, 좋다라는 이야기를 가장 많이 들어봤기 때문일것입니다.
- 현업에서 바라보는 TDD
    - 현업에서 TDD를 강조하는 이유는 간단합니다. 실제 서비스 운영 중 발생하는 문제점들이 대부분 테스트 케이스의 부재나 부족에서 비롯되기 때문입니다.
    - 서비스의 규모가 커지고 복잡성이 증가할수록 버그나 결함을 사전에 예방하는 테스트 케이스의 중요성은 더욱 높아집니다. 따라서 테스트를 “잘(이쁘게)” 작성하는것도 중요하지만, 다른 “잘(시스템의 안정성을 위한 장치로서)” 작성했는지가 더 중요합니다
    - 위의 뉘앙스에 대한 느낌이 오시나요~?
- TDD가 어려운 이유
    - 많은 개발자들이 TDD를 어렵다고 느끼는 이유는 명확합니다.
    - 현실에서는 프레임워크나 환경이 완벽히 셋업되지 않은 상태에서 TDD를 진행해야 하는 경우가 많기 때문입니다.
    - 프레임워크의 사용법을 명확히 이해하고, 이를 바탕으로 테스트 가능한 구조를 만드는 데 상당한 시간과 노력이 소요됩니다.
    - 쉽게 말해, TDD가 어려운 이유는 코드 자체의 복잡성 때문이 아니라 "테스트하기 좋은 환경"이 구축되지 않았기 때문입니다.
- **실제적인 조언**
    - 현업에서는 처음부터 완벽한 TDD 환경을 구축하기보다는, 점진적으로 테스트 가능한 구조를 만들어 나가는 접근법을 권장합니다.
    - 물론 TDD가 가능한 환경이라면 바로 진행해야죠~!
    - 하지만, 제가 말한 환경이 컴퓨터의 프레임워크 세팅만 이야기 하는것은 아닙니다. 환경은 모든 것을 포함합니다. 개발 기간, 프레임워크의 선택, 인프라 구성등등 입니다.
    - 핵심 기능부터 우선적으로 테스트 케이스를 작성하고, 이를 통해 서비스가 점점 더 견고해질 수 있도록 발전시켜 나가는 방식이 효과적입니다.
    - 즉, TDD의 도입이 어렵다고 하더라도 테스트 코드만큼은 잘 작성해야 합니다. 테스트 코드가 충실히 작성된 시스템은 TDD가 완벽히 도입되지 않았더라도 품질과 안정성을 상당 부분 보장할 수 있기 때문입니다.
    - 항상 실제 서비스의 안정성과 유지보수성을 최우선으로 고려하며 접근하는 것이 가장 중요합니다.
    (TDD를 꼭 해야해도 좋지만, 테스트가 꼭 필요해 라는 관점이 중요합니다.)

### **성장 방향과 서버 설계의 중요성**

<aside>
❗

서버 설계는 백엔드 개발자의 핵심 역량입니다.

</aside>

- 개발자에게 완벽한 공부란 가능한가?
    - 임포스터 신드롬을 아시나요?
    - 임포스터 신드롬은 자신이 충분히 능력 있고 자격이 있음에도 불구하고, 스스로를 과소평가하면서 "내가 잘하고 있는 게 맞나?" 혹은 "언제 들킬까?" 같은 불안감을 느끼는 현상입니다.
    - 사실 많은 개발자들이 임포스터 신드롬을 느낍니다. 가장 큰 이유는 개발이라는 분야가 가지고 있는 특수성 중 방대한 양과 기술 발전 속도가 빠른것이 가장 큰 원인으로 볼수 있습니다.
    - 혹시 내 알고 있는 개발 지식이 너무 낮거나 얕다고 생각하고 있나요?
    - “완벽한 개발을 하기위해서 완벽하게 공부하고 수행한다!” 라는것은 사실 불가능에 가깝습니다. 너무 방대한 분야거든요.
    - 이 말이 가능했다면 우리가 사용하는 서비스들은 장애가 없어야 합니다. 하지만 그렇지 않죠
    
- 전략의 변화: 모든 것을 외우는 공부에서 필요할 때 리서치하는 방식으로
    - 위의 내용을 바탕으로 여러분은 앞으로 전략을 바꿀 필요가 있습니다.
    - “완벽하게 지식을 습득하여 내것으로 만들어 머릿속에 넣어 둔다”에서 “ 필요한 지식 항목을 나열해 두고, 그 중에서 실제 서비스에 맞게 필요한 부분을 골라 깊이 공부(리서치)한다”로 바꾸는 것입니다.
    - 모든 파라미터를 다 외우는 게 중요할까요? 아니면 필요한 상황에서 적절한 도구를 찾고 활용할 줄 아는 능력이 더 중요할까요?
    - 키워드에 집중 하는것이 아닙니다. 상황에 따라 어떤것들이 필요한지 이야기 할수 있으면 키워드는 따라 옵니다.(키워드는 대화에서 중요하지만 모른다고 해서 내용도 모르는것은 아닐 수 있습니다)
    - **예를 들어:**
        - 서비스가 갑자기 인기 상승으로 트래픽이 몰렸을 때, 로드밸런싱과 캐싱 전략을 이해하고 있으면 신속하게 대응할 수 있습니다.
        - 예상하지 못한 API 지연 문제가 발생했을때, 서버 설계 경험을 갖추었다면 단순한 코드 수정이 아닌, 시스템 전체를 보는 관점에서 로그 분석, 분산 트레이싱(Distributed Tracing), 성능 모니터링 도구를 통해 지연 원인을 빠르게 식별하고 문제를 해결할 수 있습니**다**
    
- 전략의 변화: 면접과 나의 역량을 기르는 방법
    - 여러분은 개인적으로 역량을 기르기 위해 어떻게 하고있나요?
    - 혹시 내가 부족한 부분을 막연하게 생각하고, 개인 프로젝트를 의미없이 수행하고 있지 않나요?
    - 예를 들어 대규모 트래픽을 경험이 부족하다면, Jmeter를 통해 실제 트래픽을 시뮬레이션하여 포트폴리오를 만드는 것이 훨씬 효과적입니다.  이처럼, 내가 부족한 점을 파악하고 해당 경험을 할 수 있도록 내 개인 포트폴리오를 구성하는것이 중요합니다.
    - 개발자로서 성장 방향이 막연할 때 많은 사람들이 이직을 고민합니다. 그럴 때일수록 여러분이 갖추어야 할 전략은 막연한 개인 프로젝트가 아니라 명확한 목적과 계획이 담긴 프로젝트입니다
- 이번 강의는 매우 중요합니다.
    - 이 강의 전체 과정을 통해 여러분은 **무엇이 중요한지 전체적인 그림을 얻을 수 있습니다.**
    - 특히, 서버설계는 매우 중요합니다.
    - 개발 능력을 단지 코드 작성에만 한정하지 않고, 서비스 전체를 바라보는 시각을 제공하기 때문입니다.
    - 이는 개발자로서 코딩으로 능력을 한정하는것이 아닌 서비스 관점 및 설계로 생각을 바꿀 수 있는 중요한 포인트이기 때문입니다.
    - 이번 챕터를 통해, 여러분이 알고 있던 여러 요소들이 어떻게 모여 시스템이 구성되는지 알 수 있게 될 것입니다.
    - 이를 통해 앞으로 **스스로 부족한 부분을 명확히 하고 무엇을 공부할지 자율적으로 결정**할 수 있게 될 것입니다.
    

## 이번 강의에서 배울 것

<aside>
⚓ **이번 챕터의 의도와 목표**

</aside>

- 앞으로 4주간 서버구축에 대해 배우게 됩니다. 회사 면접 등 채용 단계에서 서버 설계, 아키텍처, DB에 대해 답을 할 수 있는 상태로 만드는 것이 목표입니다.
- 서버 설계부터 시작하여, 명확한 아키텍처와 애플리케이션 구조를 배우고, 그 후에 데이터베이스를 설계하여 데이터를 효과적으로 관리할 수 있도록 합니다. 마지막으로 복잡한 현실 문제인 동시성 처리와 고급 인프라 요소를 학습하여 실무에서 발생할 수 있는 다양한 문제 상황에 대한 실질적인 대응 능력을 키우기 위함입니다.

<aside>
⛵ **이번 주차 목표**

</aside>

- 이번 강의의 목표는 서버 설계에 대한 기본적인 개념과 중요성을 이해하고, 실무에서 반드시 고려해야 할 핵심 요소들을 배워 실제 설계 업무에 자신 있게 참여할 수 있도록 만드는 것입니다.
- 이번 강의의 주요 내용
    - 서버 설계의 정의와 중요성 이해
    - 서버 설계 시 반드시 고려해야 할 핵심 요소 (성능, 확장성, 가용성, 유지보수성, 보안성, 비용 효율성)
    - 사전 리서치 및 요구사항 정의 방법
    - 기능적/비기능적 요구사항과 트래픽 예측의 중요성
    - 설계를 효과적으로 문서화하는 방법

---

## **서버 설계란 무엇이며 왜 중요한가?**

<aside>
🚤

이번 강의에서는 단순히 코드를 작성하는 것 이상으로, 우리가 만드는 서비스가 실제로 어떻게 구성되고 운영되는지를 이해하는 것이 정말 중요합니다. 백엔드 개발자로서 단순히 기능만 구현하는 것이 아니라, 그 기능이 어디에 들어가고, 어떤 방식으로 다른 시스템과 연결되는지, 어떤 구조로 서비스 전체가 움직이는지를 생각할 수 있어야 합니다. 

</aside>

- 서버 설계란 말 그대로 서버와 관련된 시스템이 어떻게 구성되어야 할지를 미리 계획하는 일입니다. 우리가 흔히 "백엔드 개발"이라고 할 때 단순히 데이터를 주고받는 API만 떠올릴 수 있습니다. 그러나 사실 이 API들이 어떤 구조 위에 올라가야 하고, 어떤 식으로 관리되어야 하는지는 설계 단계에서 결정됩니다. 서버 설계는 기술적인 문제를 넘어서 서비스의 품질과 안정성, 운영 효율성에 깊은 영향을 줍니다.
- 쉽게 말하면 서버 설계는 마치 건물을 짓기 전에 설계도를 그리는 것과 같습니다. 벽돌이나 창문을 어디에 둘지, 전기는 어떻게 연결할지, 비상구는 어디로 빠져야 할지를 미리 계획하지 않고 무작정 짓기 시작한다면 나중에 큰 문제가 생기기 마련이죠. 소프트웨어도 마찬가지입니다. 설계 없이 코딩부터 시작하면 예상치 못한 문제들이 쏟아지고, 결국 전체를 뜯어고치는 일이 벌어질 수 있습니다..
- 따라서 서버 설계를 한다는 것은 단순히 기술적인 선택을 넘어서서, 전체 시스템이 어떤 방향으로 나아갈지를 결정짓는 중요한 단계입니다. 그리고 이 설계를 잘 하려면 현재 당면한 문제뿐 아니라 미래에 발생할 수 있는 상황까지 예측하고 대비해야 합니다.
- 서버 설계 시 꼭 생각해야 할 핵심 요소들은 다음과 같습니다:
    - **성능(Performance)**: 사용자가 서비스를 사용할 때 빠르게 반응할 수 있어야 합니다. 예를 들어, 검색창에 검색어를 입력했을 때 결과가 5초 이상 걸린다면 사용자는 금방 떠나버릴 겁니다. 이런 성능 문제를 방지하기 위해 캐시를 사용하거나, 데이터 처리 방식을 최적화하는 등의 방법이 필요합니다.
    - **확장성(Scalability)**: 지금은 사용자 수가 적어도, 나중에 더 많은 사람들이 사용할 수 있습니다. 그럴 때를 대비해서 미리 구조를 잘 짜 두어야 합니다. 서버를 쉽게 추가할 수 있는 구조라면, 트래픽이 많아졌을 때도 안정적으로 대응할 수 있습니다.
    - **가용성(Availability)**: 서버가 갑자기 꺼지거나 장애가 생겼을 때, 서비스가 멈추지 않고 계속 돌아갈 수 있어야 합니다. 이를 위해 서버를 이중화하거나 자동으로 복구되는 시스템을 도입하는 것이 중요합니다.
    - **유지보수성(Maintainability)**: 개발이 끝이 아니라는 것을 기억해야 합니다. 시간이 지나면서 새로운 기능을 추가하거나 기존 기능을 수정하는 일이 반복됩니다. 이때 시스템이 잘 정리되어 있지 않으면 하나를 수정할 때 여러 군데가 같이 망가지는 일이 생깁니다. 기능별로 코드를 잘 나누고, 명확한 구조를 유지하는 것이 중요합니다.
    - **보안성(Security)**: 사용자 정보나 중요한 데이터가 외부로 유출되지 않도록 설계 단계부터 보안을 고려해야 합니다. HTTPS 사용, 데이터 암호화, 접근 권한 관리 같은 기본적인 보안 설정이 반드시 포함되어야 합니다.
    - **비용 효율성(Cost Efficiency)**: 기술적으로 훌륭한 시스템이라도 유지비용이 너무 많이 들면 운영이 어려워질 수 있습니다. 초기에는 단순한 구조로 시작하되, 향후 트래픽 증가에 대비해 점진적으로 확장할 수 있는 방향으로 설계하는 것이 좋습니다.
- 이 모든 요소는 서로 영향을 주고받습니다. 예를 들어 성능을 높이기 위해 캐시를 도입하면, 데이터의 최신성이 떨어질 수도 있습니다. 보안적으로 관리가 어려워질 수도 있습니다. 반대로 비용을 줄이려고 너무 간단한 구조를 선택하면, 나중에 트래픽이 늘었을 때 대응이 어려워질 수 있죠. 그래서 설계자는 이 모든 요소의 균형을 잘 맞추는 것이 중요합니다.
- 설계가 부족한 시스템은 초기에야 잘 돌아갈 수 있습니다. 하지만 서비스가 커지고, 사용자가 많아지고, 기능이 늘어나면 문제가 쌓이기 시작합니다. 장애가 자주 발생하고, 수정하려 해도 어디서 문제가 생기는지 알기 어려워지고, 유지보수하는 사람도 점점 지치게 되죠. 결국 시스템 전체를 새로 만들게 되는 상황도 흔합니다.
- 하지만 반대로 잘 설계된 시스템은 이런 문제들을 미리 예방할 수 있습니다. 새로운 기능도 빠르게 붙일 수 있고, 문제가 생겨도 빨리 파악해서 고칠 수 있습니다. 협업도 쉬워지고, 코드 품질도 자연스럽게 높아집니다. 그러니까 설계란 단순히 이론적인 이야기가 아니라, 실무에서 정말 큰 차이를 만드는 중요한 일이에요.
- 지금처럼 기술이 빠르게 변하고, 사용자들의 기대가 높아지는 시대에는 단순히 코드를 잘 짜는 것만으로는 부족합니다. 전체 시스템이 어떻게 돌아가는지를 이해해야 합니다. 문제가 생겼을 때 어떤 방식으로 해결할 수 있을지를 미리 고민할 수 있어야 해요. 백엔드 개발자는 점점 더 시스템 전체를 이해하고, 문제를 예측하고, 해결책을 설계할 수 있는 역량이 요구되고 있습니다.
- 이번 강의를 통해 여러분이 단지 기능 구현 능력뿐 아니라, 전체 서비스를 바라보고 설계할 수 있는 시야를 넓힐 수 있기를 바랍니다. 이것이 진짜 개발자의 실력이고, 이 실력이 여러분의 커리어를 한 단계 더 성장시켜줄것입니다.

---

## **사전 리서치: 트래픽 예상과 요구사항 정의의 중요성**

<aside>
💡

서버를 어떻게 설계할지 고민하기에 앞서, 반드시 먼저 진행해야 하는 작업이 있습니다. 바로 사전 리서치입니다. 이 단계는 단순히 기술을 고르는 걸 넘어서, 우리가 만들 서비스가 어떤 기능을 갖춰야 하고 얼마나 많은 사용자를 감당할 수 있어야 하는지, 또 어떤 제약이 있는지를 전반적으로 파악하는 과정입니다.

사전 리서치를 철저히 하면 그만큼 안정적이고 확장 가능한 서버 설계를 할 수 있습니다. 반대로 이 단계를 대충 넘기면, 개발 중간이나 운영 중에 생각지도 못한 문제가 터질 수 있습니다.

</aside>

### **기능적 요구사항이란?**

- 기능적 요구사항은 말 그대로 "무엇을 할 수 있어야 하는가"를 정의하는 것입니다. 예를 들어 전자상거래 사이트를 만든다고 하면:
    - 상품 목록을 볼 수 있어야 하고,
    - 상품을 장바구니에 담을 수 있어야 하며,
    - 주문을 넣고,
    - 결제를 진행해야 하고,
    - 사용자는 로그인하거나 회원가입을 할 수 있어야 하겠죠.
- 이런 기본 기능들이 무엇인지 미리 목록으로 정리해두면, 어떤 API가 필요한지, 어떤 데이터베이스 테이블이 필요한지, 어떤 화면이 있어야 할지가 점점 명확해집니다.
- 또한 사용자 시나리오(예: "손님이 상품을 보고 → 장바구니에 담고 → 결제까지 진행하는 흐름")를 흐름도로 그려보면 더욱 명확해집니다. 이렇게 하면 개발을 시작할 때 혼란이 적고, 설계도 훨씬 자연스럽게 진행됩니다.

### **비기능적 요구사항이란?**

이번에는 "어떻게 동작해야 하는가"에 대한 이야기입니다. 이건 성능, 안정성, 보안 같은 시스템의 품질을 정의하는 기준입니다.

- **성능**: 예를 들어 특정 요청이 몇 초안에 응답해야 할까요? 게시판 글 목록은 몇 개까지 한 번에 보여줄 수 있어야 할까요? 이런 기준이 없으면 속도가 느려도 문제인지 아닌지 판단하기 어렵습니다.
- **확장성**: 지금은 하루 사용자 100명일 수 있지만, 다음 달엔 10배가 될 수도 있죠. 그때 서버를 어떻게 늘릴 건지, 미리 생각해두는 게 좋습니다.
- **가용성**: 서버가 갑자기 꺼져도 서비스가 중단되면 안 됩니다. 이를 위해 이중화나 백업, 자동 복구 기능 같은 것을 고려해야 합니다.
- **보안**: 로그인 정보는 안전하게 암호화되어야 하고, 민감한 정보는 외부에 노출되지 않아야 합니다. 기본적으로 HTTPS는 필수고, 로그인/회원정보 관리에는 인증과 인가 체계를 넣어야겠죠.
- **유지보수성**: 코드가 잘 나눠져 있어야 수정하거나 기능을 추가할 때 부담이 덜합니다. 예를 들어 로그인 기능과 상품 기능이 뒤섞여 있으면 나중에 유지보수가 어렵습니다.

### **트래픽 예측과 규모 추산의 중요성**

서버 설계를 할 때 "얼마나 많은 사람들이 사용할까?"를 예상하는 건 매우 중요합니다.

- 하루 사용자 수(DAU)는 얼마인지,
- 동시에 접속하는 사람은 몇 명인지,
- 초당 요청(TPS, RPS, QPS)은 얼마나 들어올지,
- 한 달에 얼마나 많은 데이터가 쌓일지 등을 예측합니다.

예를 들어 하루에 1만 명이 쓰는 서비스라면, 피크 시간대에 수백 명이 동시에 접속할 수 있습니다. 그때 서버가 버티지 못하고 느려지거나 멈춘다면 사용자 경험에 큰 타격을 주게 됩니다.

그래서 미리 이런 수치를 추산하고, 그에 맞는 서버 수나 캐시 전략을 고려하는 것이 좋습니다. 물론 100% 정확할 순 없지만, 비슷한 서비스의 통계나 경쟁사 사례를 참고하면 충분히 합리적인 예측이 가능합니다.

### **기술 스택과 현실적인 제약 사항 파악하기**

개발을 시작하기 전에 어떤 기술을 쓸지도 정해야 합니다. 예를 들어:

- 데이터를 어떻게 저장할 건지 (MySQL? MongoDB?)
- 실시간 기능이 필요한지 (WebSocket?)
- 인증은 어떻게 할 건지 (JWT? OAuth?)

이런 기술적인 판단을 내리기 위해서는 해당 기술의 장단점도 알아야 하고, 우리 팀이 그 기술을 다룰 수 있는지도 생각해야 합니다.

또한 현실적인 제약도 고려해야 합니다:

- 예산이 충분한가요?
- 팀원 수는 몇 명인가요?
- 마감 기한은 언제인가요?
- 기존에 구축된 시스템이 있다면 그것과 어떻게 연동할 건가요?

예를 들어 쿠버네티스가 좋아 보일 수 있지만, 팀에 운영 경험이 없으면 오히려 불안정해질 수 있습니다. 처음에는 단순한 구성으로 시작하고, 나중에 필요에 따라 확장하는 게 좋은 전략일 수 있어요.

### **조사 결과는 문서로 정리해야 합니다**

사전 리서치를 아무리 잘해도 머릿속에만 있으면 소용이 없습니다. 꼭 문서로 정리해서 팀원들과 공유해야 합니다.

- 요구사항 명세서 (기능 목록, 설명)
- 시스템 개요서 (전체 구조 요약)
- 기술 스택 선택 이유
- 사용자 흐름도

이런 자료는 이후 설계, 개발, 테스트, 운영에 이르기까지 계속 참고하게 됩니다. 팀원 간 의사소통을 도와주고, 빠르게 새로운 팀원이 들어왔을 때도 큰 도움이 됩니다.

### **마무리: 설계는 문제를 이해하는 데서 시작됩니다**

서버 설계는 단순히 "이걸 만들자"로 시작하는 것이 아닙니다. 무엇을, 왜 만들고, 어떤 환경에서 어떻게 동작해야 하는지를 충분히 이해한 뒤에야 제대로 된 설계를 할 수 있습니다.

기능과 트래픽, 기술 제약과 현실 조건들을 미리 파악하고, 문서로 정리해두는 것만으로도 프로젝트의 성공 가능성은 훨씬 높아집니다.

사전 리서치는 시간 낭비가 아니라, 가장 현명한 시간 투자입니다.

---

---

## **애플리케이션 구조 설계: 모듈 구성, 도메인 설계, API 구조**

<aside>
🚤

이번에는 백엔드 애플리케이션의 내부 구조를 어떻게 짜야 하는지를 다룹니다. 단순히 코드를 기능별로 나누는 것을 넘어서, 서비스가 커지고 복잡해져도 유연하게 대응할 수 있는 구조를 만드는 것이 핵심입니다. 특히 유지보수나 확장, 협업 측면에서 더 안정적인 개발을 가능하게 하려면 처음부터 잘 설계된 구조가 필요합니다.

이번 장에서는 크게 네 가지 파트를 중심으로 살펴보겠습니다:

1. 모듈 및 도메인 설계
2. 아키텍처 스타일(모놀리식 vs 마이크로서비스)
3. API 설계와 관리
4. 데이터베이스 설계 및 관리
</aside>

### **모듈 및 도메인 설계**

모듈 설계는 시스템 안의 기능들을 어떤 기준으로 나누고 연결할지를 정하는 것입니다. 특히, 모듈 설계를 도메인 중심으로 진행하는 방식은 DDD(Domain-Driven Design, 도메인 주도 설계) 패턴과 관련이 깊습니다. DDD는 복잡한 비즈니스 로직을 중심으로 도메인 모델을 명확히 정의하고 이를 기반으로 애플리케이션을 설계하는 접근법입니다. 여기서 '도메인'이란 우리가 만들 서비스의 주요 개념들을 말합니다. 예를 들어 온라인 쇼핑몰이라면 상품, 장바구니, 주문, 결제, 사용자 같은 게 도메인이 됩니다.

- **도메인별로 나누기 (DDD 패턴)**
    - 각 도메인을 하나의 모듈로 구성하면 각 영역의 책임이 명확해집니다. 예를 들어, '주문' 모듈은 주문 생성, 조회, 취소 등의 기능을 담당하고, '회원' 모듈은 로그인, 회원가입, 사용자 정보 수정 같은 기능을 담당하는 식이죠. 이처럼 도메인 중심으로 나누면 각각의 기능이 서로 덜 얽히기 때문에 나중에 유지보수가 훨씬 쉬워집니다.
    - 예를 들어 Java(Spring) 기반의 애플리케이션에서 패키지 구조를 도메인 기준으로 나누면 다음과 같이 구성할 수 있습니다:
        
        ```markdown
        com.example.myshop
        ├── user
        │   ├── controller
        │   ├── service
        │   ├── repository
        │   └── domain
        ├── order
        │   ├── controller
        │   ├── service
        │   ├── repository
        │   └── domain
        ├── product
        │   ├── controller
        │   ├── service
        │   ├── repository
        │   └── domain
        └── common
            ├── config
            └── exception
        ```
        
    - 위 구조에서 각 도메인(예: user, order, product)은 독립적인 하위 모듈처럼 관리되며, 내부적으로 controller, service, repository, domain 등의 계층 구조를 그대로 유지합니다. 공통으로 사용하는 설정이나 예외 처리 등은 `common` 패키지에 분리해서 재사용성을 높입니다.
- **기술 중심으로 나누기 (기술 기반 패턴)**
    - 기술 기반 패턴은 비슷한 기능을 가진 코드를 기술 단위로 나누는 방식입니다. 예를 들어, 모든 컨트롤러를 한곳에 모으고, 모든 서비스를 따로 묶어놓는 구조입니다.
        
        ```markdown
        com.example.myshop
        ├── controllers
        │   ├── UserController
        │   ├── OrderController
        │   └── ProductController
        ├── services
        │   ├── UserService
        │   ├── OrderService
        │   └── ProductService
        ├── repositories
        │   ├── UserRepository
        │   ├── OrderRepository
        │   └── ProductRepository
        └── domains
            ├── User
            ├── Order
            └── Product
        ```
        
    - 이 방식은 초기 구현 시 간단하고 직관적이지만, 서비스가 커지고 복잡해질수록 관련된 기능이 분산되어 유지보수와 확장이 어렵습니다. 또한 특정 도메인의 변경 사항이 여러 위치에 걸쳐 있어서 변경 관리가 까다로워질 수 있습니다.
    

DDD 패턴은 비즈니스 중심으로 설계가 이루어져 유지보수와 확장성이 뛰어나지만, 기술 기반 패턴은 초기 개발이 쉽고 직관적입니다. 서비스의 규모와 복잡성, 팀의 특성에 따라 적절한 패턴을 선택하는 것이 중요합니다.

### **아키텍처 스타일: 모놀리식 vs 마이크로서비스**

- 애플리케이션의 아키텍처 스타일을 결정할 때 크게 모놀리식(monolithic)과 마이크로서비스(microservices) 아키텍처를 고려할 수 있습니다.
- 모놀리틱 아키텍처
    
    ![Untitled.png](attachment:7d4a3705-0943-4906-8e65-acd22d72bbe6:Untitled.png)
    
    - **정의**:
        - 모놀리틱 아키텍처는 하나의 큰 코드베이스로 구성된 애플리케이션
        - 모든 기능이 하나의 애플리케이션 내에 포함
    - **장점**:
        - **간단한 배포**: 모든 코드가 하나의 코드베이스에 포함되어 있어 배포가 단순
        - **단일 데이터베이스**: 하나의 데이터베이스를 사용하여 데이터 일관성을 쉽게 유지할 수 있음
    - **단점**:
        - **확장성 부족**: 특정 기능을 확장하려면 전체 애플리케이션을 확장해야함
        - **긴 개발 주기**: 작은 변경 사항도 전체 애플리케이션을 다시 배포해야함
        - **유연성 부족**: 새로운 기술 도입이 어렵고, 특정 모듈에 종속적임
- **Microservices Architecture (MSA)**
    
    ![Untitled.png](attachment:42c111e6-e962-47f3-bd4f-97122dd6a7a4:Untitled.png)
    
    - MSA는 하나의 애플리케이션을 여러 개의 독립적인 서비스로 분리하여 개발, 배포, 유지보수를 용이하게 하는 소프트웨어 아키텍처 스타일
    - 각 서비스는 특정 비즈니스 기능을 수행하며, 서로 독립적으로 배포되고 확장될 수 있음
    - 서비스 간의 통신은 주로 HTTP/HTTPS, 메시지 큐 등을 통해 이루어짐
        
        ![Untitled.png](attachment:5ef9d28d-df21-49f6-be07-916dc8ab4026:Untitled.png)
        
    - **정의**:
        - MSA는 여러 개의 독립적인 서비스로 구성된 애플리케이션
        - 각 서비스는 특정 비즈니스 기능을 수행
    - **장점**:
        - **확장성**: 각 서비스는 독립적으로 확장 가능, 특정 기능에 대한 성능 최적화가 용이
        - **유연성**: 다양한 기술 스택을 사용하여 서비스별 최적화 가능
        - **독립적 배포**: 서비스별로 독립적 배포가 가능하여 배포 주기를 단축
        - **작은 팀 구성**: 서비스별 작은 팀으로 구성되어 민첩한 개발 가능
    - **단점**:
        - **복잡성**: 서비스 간 통신, 데이터 일관성 유지, 트랜잭션 관리 등의 복잡성이 증가
        - **운영비용**: 각 서비스의 모니터링, 로깅, 장애 대응 등을 개별적으로 관리해야 하므로 운영 비용이 증가
        - **데이터 관리**: 분산된 데이터베이스로 인해 데이터 일관성 유지가 어려울 수 있음
        - **네트워크 지연**: 서비스 간의 통신이 네트워크를 통해 이루어지므로 지연 시간이 발생할 수 있음

### **API 설계와 관리**

- API는 서버와 클라이언트가 소통하는 "약속"입니다. 쉽게 말해 서버가 어떤 요청을 받고, 어떤 결과를 돌려줘야 하는지를 명확히 정해주는 역할입니다. 예를 들어 온라인 쇼핑몰에서는:
    - 상품 목록을 요청하면 서버가 상품 데이터를 보내줘야 하고,
    - 로그인 요청을 보내면 서버가 사용자 인증을 처리해야 하며,
    - 장바구니에 상품을 담거나,
    - 결제를 요청하는 등 다양한 동작을 클라이언트가 서버에 요청하게 됩니다.
- 이때 API를 잘 설계하면 개발자들이 헷갈리지 않고 기능을 빠르게 구현할 수 있습니다. 대표적으로 쓰이는 API 설계 방식이 RESTful입니다
    - URL은 명사형으로, 예를 들어 `/users`, `/products`, `/orders`처럼 구성하고,
    - 각각의 요청은 서로 독립적으로 처리되도록 합니다. 이걸 "stateless" 방식이라고 부릅니다.
    - 요청과 응답은 대부분 JSON 형태로 주고받으며,
    - 상태 코드는 HTTP의 표준 코드(예: 200 OK, 201 Created, 400 Bad Request, 404 Not Found)를 활용합니다.
- 이런 규칙들을 지키면, 클라이언트는 서버가 어떤 식으로 응답할지 예측할 수 있기 때문에 개발 속도와 안정성이 높아집니다.
- API가 계속 발전하다 보면, 기존 기능을 유지하면서 새로운 기능을 추가해야 할 때가 있습니다. 이럴 때는 API에 버전 번호를 붙이는 방식이 유용합니다:
    - `/api/v1/users`, `/api/v2/users` 처럼 버전을 명시하면,
    - 기존 클라이언트는 기존 버전을 계속 사용할 수 있고,
    - 새로운 클라이언트는 최신 버전을 사용할 수 있습니다.
- 보안도 API 설계에서 매우 중요한 요소입니다:
    - HTTPS로 통신을 암호화하여 중간에서 데이터가 탈취되는 것을 막고,
    - 로그인한 사용자를 식별하기 위해 JWT(Json Web Token) 같은 인증 토큰을 사용하고,
    - 역할별로 접근할 수 있는 API를 제한하는 등 권한 관리를 세밀하게 설계해야 합니다.
- API 문서화는 협업과 유지보수에 있어서 빼놓을 수 없는 부분입니다. Swagger(OpenAPI) 같은 도구를 사용하면:
    - 실제 코드에 기반한 API 문서를 자동으로 생성할 수 있고,
    - 문서 상에서 바로 테스트도 가능하며,
    - 외부 개발자나 협력사에게도 이해하기 쉬운 형식으로 API를 제공할 수 있습니다.
- 운영 환경에서는 API를 하나씩 직접 연결하기보다는 API Gateway를 통해 관리하는 경우도 많습니다. 이 방식은:
    - 인증, 라우팅, 로깅, 속도 제한, 오류 처리 등을 중앙에서 일괄적으로 관리할 수 있고,
    - 마이크로서비스 구조처럼 여러 개의 백엔드가 있는 환경에서는 더욱 유용합니다.
- 결론적으로, API 설계는 단순히 URL을 만드는 수준을 넘어서, 서비스 전체의 일관성과 안정성을 책임지는 중요한 작업입니다.

### **데이터베이스 설계 및 관리**

- 데이터베이스는 애플리케이션에서 생성되고 사용되는 모든 데이터를 저장하고 관리하는 중심 시스템입니다. 예를 들어 쇼핑몰 서비스를 운영한다고 했을 때:
    - 사용자 정보, 상품 정보, 주문 내역, 리뷰, 결제 기록 등 모든 정보는 데이터베이스에 저장됩니다.
- 이 데이터를 잘 관리하려면 데이터베이스 구조를 체계적으로 설계해야 합니다. 기본적으로는 아래와 같은 방식으로 구성됩니다:
    - 사용자 정보를 담는 `users` 테이블,
    - 상품 정보를 담는 `products` 테이블,
    - 주문 정보를 담는 `orders` 테이블 등으로 역할을 나눕니다.
- 이때 각 테이블에는 **기본 키(PK)**가 존재하여 각 데이터를 유일하게 식별할 수 있게 합니다. 예를 들어 `users`테이블에서는 `user_id`가 PK가 되고, `orders` 테이블에서는 `order_id`가 PK가 됩니다.
- 테이블 간의 관계는 **외래 키(FK)**를 이용해서 연결합니다. 예를 들어 주문 테이블의 `user_id`는 사용자 테이블의 `user_id`를 참조하게 하면:
    - 어떤 사용자가 어떤 주문을 했는지 연결 지을 수 있고,
    - 잘못된 데이터(존재하지 않는 사용자로 주문 생성 등)를 방지할 수 있습니다.
- 현업에서는 대부분 데이터베이스의 설계 및 유지보수를 위해 명확한 규칙과 가이드라인을 마련해둡니다. 이를 **데이터베이스 설계 컨벤션**이라고 하며 주로 다음과 같은 내용을 포함합니다
    - 테이블 이름은 복수형(snake_case)을 사용합니다. 예: `users`, `order_items`
    - 기본 키는 `id`, 복합 키는 명확한 이름(예: `user_id`, `product_id`)으로 명시합니다.
    - 외래 키는 참조하는 테이블명을 포함하여 명확히 정의합니다. 예: `user_id` → `users.id`
    - 인덱스, 제약조건 등 데이터베이스 객체 이름 또한 규칙적으로 설정합니다.
- 이러한 테이블과 관계의 구조를 ERD(Entity-Relationship Diagram)로 표현할 수 있습니다. ERD는 데이터베이스의 구조를 시각적으로 표현한 도구로:
    - 예를 들어, 쇼핑몰 서비스의 간단한 ERD를 그리면 다음과 같은 구조가 나올 수 있습니다:
    
    ![image.png](attachment:dd6d0e66-a71f-48c6-b073-644ce2f8c8ad:image.png)
    
    - `users` 테이블 (사용자 정보 저장)
        - `user_id` (PK), `name`, `email`, `password`
    - `products` 테이블 (상품 정보 저장)
        - `product_id` (PK), `name`, `price`, `stock`
    - `orders` 테이블 (주문 정보 저장)
        - `order_id` (PK), `user_id` (FK → users.user_id), `order_date`, `total_amount`
    - `order_items` 테이블 (주문 상세 항목 저장)
        - `order_item_id` (PK), `order_id` (FK → orders.order_id), `product_id` (FK → products.product_id), `quantity`, `price`
- 이렇게 구성하면 한 사용자가 여러 주문을 할 수 있고, 하나의 주문에는 여러 상품이 담길 수 있는 구조가 됩니다. 이런 관계를 시각적으로 표현하면, 각 테이블이 선으로 연결되고 관계(1:N, N:M 등)가 명확히 드러나 이해하기 쉬워집니다.
    - 테이블(엔티티)을 사각형으로 나타내고,
    - 엔티티 간의 관계를 선과 기호를 통해 표현합니다.
    - 이를 통해 테이블 간의 연결 구조와 데이터 흐름을 쉽게 이해할 수 있습니다.
- 또한 데이터의 무결성을 위해 다음과 같은 제약 조건도 자주 사용됩니다:
    - `NOT NULL`: 필수 입력값을 설정할 수 있습니다.
    - `UNIQUE`: 중복이 안 되는 값(예: 이메일 주소 등)을 제한합니다.
    - `CHECK`: 특정 값 범위를 제한할 수 있습니다.
- 여러 작업을 하나의 논리 단위로 묶어서 처리하는 **트랜잭션**은 데이터의 일관성을 지키는 데 중요한 역할을 합니다. 예를 들어:
    - 주문 생성과 동시에 재고를 차감하고,
    - 포인트를 적립하며,
    - 결제 상태를 업데이트하는 작업이 모두 성공해야 한다면,
    - 이 작업들을 하나의 트랜잭션으로 묶어 모두 성공하거나 모두 실패하도록 처리합니다.
- 성능 최적화도 중요합니다. 데이터가 많아지면 검색이 느려질 수 있으니:
    - 자주 조회되는 컬럼에 인덱스를 설정하고,
    - 정렬이나 JOIN 등에 사용되는 컬럼에도 인덱스를 추가해서 처리 속도를 높입니다.
- 데이터가 아주 많아지면 **샤딩(Sharding)**이라는 전략을 쓰기도 합니다. 이는 데이터를 여러 서버나 테이블에 나눠서 저장하고 관리하는 방식입니다.
    - 운영 중에는 다음과 같은 관리 작업도 필요합니다:
    - 정기적인 백업: 데이터 손실에 대비하기 위해 주기적으로 데이터를 저장합니다.
    - 복제(Replication): 한 서버가 장애가 나더라도 다른 서버가 대신 동작할 수 있게 데이터 복사본을 유지합니다.
    - 모니터링: 데이터베이스의 응답 시간, 쿼리 성능, 자원 사용량 등을 주기적으로 확인해서 문제가 생기기 전에 조치를 취할 수 있습니다.
- 데이터베이스 설계와 관리는 단순히 테이블을 만드는 것이 아니라, 데이터의 흐름을 이해하고, 안정성과 성능을 함께 고려해서 구조화하는 과정입니다.

---

## **인프라 설계 요소: 로드밸런서, 캐시, 메시지 큐, 컨테이너 등**

<aside>
🚤

애플리케이션 내부 구조를 설계했다면, 이를 **어떻게 배포하고 운영할 것인지** 인프라 측면의 설계를 고려해야 합니다. 서버 인프라 설계에서는 성능과 가용성을 높이기 위한 다양한 구성 요소를 활용합니다. 이번 장에서는 대표적인 요소들 – **로드 밸런서**, **캐시**, **메시지 큐**, **컨테이너/쿠버네티스** – 의 역할과 사용 이유, 실무 활용 예시를 살펴봅니다. 

</aside>

### **로드 밸런서 (Load Balancer)**

- **로드 밸런서**는 말 그대로 들어오는 네트워크 **부하(요청 트래픽)를 여러 서버에 고르게 분산시키는 장치 또는 소프트웨어**입니다 . 사용자는 하나의 접속 주소(예: 서비스 도메인)로 요청을 보내지만, 백엔드에는 다수의 서버가 있고 로드 밸런서가 그 중 한 서버로 요청을 전달합니다.
- 로드 밸런서를 도입하면 얻는 이점:
    - **수평 확장(Scale-out)**:
        - 단일 서버 성능의 한계를 넘어서기 위해 **서버를 추가**할 때, 로드밸런서가 새로운 서버에도 트래픽을 분배해 전체 처리량을 높일 수 있습니다 . 서버 추가 이외의 클라이언트 쪽 변경은 필요 없고, 로드밸런서가 알아서 *한 서버에 과도한 사용자가 몰리는 현상*을 막아줍니다 .
        - 예를 들어 하루 100만 요청을 처리하려면 한 서버로 부족할 수 있지만, 3대 서버로 분산하면 각 33만 요청씩 처리하게 되어 버틸 수 있습니다. 이렇게 **웹 서버 계층을 확장**할 때 로드밸런서는 필수 요소입니다.
    - **고가용성(High Availability)과 장애 대응**:
        - 로드 밸런서는 헬스 체크 등을 통해 서버들의 상태를 모니터링하고, **한 서버가 죽으면 자동으로 트래픽을 다른 서버로 돌리는** 역할도 합니다 .
        - 즉 **Single Point of Failure**를 제거해주는 것입니다.
        - 서버 2대 중 1대에 장애가 발생해도 나머지 1대로 모든 트래픽을 처리하게 하여 서비스 연속성을 높일 수 있습니다 . (물론 남은 서버에 부하가 몰리므로 완벽하진 않지만, 최소한 다운되진 않게 함)
    - **보안 측면**:
        - 로드밸런서는 대개 클라이언트 앞단에 위치하므로, 서버들의 **공인 IP**를 감춥니다.
        - 클라이언트는 로드밸런서의 IP로만 접속하고 내부 서버들은 **사설망**에서 동작하므로 공격 표면이 줄어듭니다 . 또한 TLS 인증서도 로드밸런서에서 종료(SSL offloading)시켜 내부 통신을 단순화하는 등 보조적인 역할도 합니다.
- 로드밸런서는 **하드웨어 어플라이언스** 형태(예: F5 Big-IP)나, **소프트웨어/오픈소스** 형태(예: Nginx, HAProxy), 또는 **클라우드 매니지드 서비스**(AWS ELB/ALB, GCP Cloud Load Balancing 등)로 구현할 수 있습니다.
- 현대 웹 서비스에서는 클라우드의 로드밸런싱 서비스를 주로 사용하며, 설정도 비교적 간편합니다.
- 로드밸런서 앞단에 **DNS**를 연결해 서비스 도메인으로 접근하게 하고, 백엔드 풀에 여러 서버 (또는 컨테이너)를 연결해두면, **클라우드 로드밸런서가 자동으로 트래픽을 분산**해줍니다. 또한 필요에 따라 **로드밸런싱 알고리즘**도 설정 가능한데, 라운드로빈, 최소 연결 수, 응답 시간 기반 등 시나리오에 맞게 쓸 수 있습니다  .

### **캐싱 (Caching)**

- **캐시(Cache)**는 **자주 사용되거나 생성 비용이 큰 데이터를 미리 저장해두고 빠르게 제공하기 위한 임시 저장소**입니다. 서버 설계에서 캐시는 **응답 속도 향상**과 **부하 감소**를 위해 매우 중요합니다.
- 캐시가 필요한 이유:
    - **속도 향상:** 원본 데이터 소스(예: 데이터베이스나 원격 API)에 접근하는 데 비용(시간)이 많이 드는 경우, 한 번 가져온 결과를 캐시에 저장해 두면 이후에는 훨씬 빠르게 제공할 수 있습니다 . 예를 들어 복잡한 DB 쿼리를 매번 수행하기보다는 결과를 메모리에 캐싱해두고 재사용하면 응답 시간을 크게 줄일 수 있습니다.
    - **자원 효율성:** 동일한 요청이 반복되면 캐시를 사용함으로써 원본 서버나 DB의 **부하를 줄여** 전체 시스템 자원 사용을 최적화할 수 있습니다 . CPU 집약적인 계산 결과나, 빈번히 조회되지만 잘 변하지 않는 데이터(예: 공지사항, 인기 상품 목록 등)는 캐시에 올려두고 DB나 애플리케이션 서버의 부담을 덜어주는 게 좋습니다.
    - **네트워크 절약:** 클라이언트 측(브라우저, CDN) 캐시를 활용하면 불필요한 네트워크 왕복을 줄일 수 있습니다. 예를 들어 웹 브라우저가 이미 받은 정적 파일(js/css 이미지)을 캐싱하면, 이후 요청 때 서버가 아닌 **로컬 캐시**에서 불러오므로 서버 트래픽이 감소합니다 .
- 캐시는 구현 레벨에 따라 여러 종류가 있습니다:
    - **애플리케이션 내부 캐시:** 서버 애플리케이션이 메모리 내에 캐시 객체를 두고 활용하는 방법입니다. 예를 들어 Spring Framework에서는 @Cacheable 어노테이션으로 메모리 캐시(ConcurrentHashMap 등)를 활용할 수 있습니다. 소규모 애플리케이션에 적합하나, 서버가 여러 대면 캐시 일관성 문제가 있어 분산 캐시가 필요합니다.
    - **분산 캐시 서버:** 가장 흔히 사용하는 방식으로, **Redis**나 Memcached 같은 인메모리 데이터 저장소를 캐시 서버로 두고 네트워크를 통해 조회합니다. Redis는 풍부한 자료구조와 영속성 옵션도 있어 세션 저장, 랭킹 보드, 큐 등으로도 활용되지만 기본적으로는 매우 빠른 메모리 기반 저장소라 캐시에 적격입니다. 실무에서 “Redis에 넣어 캐싱”이라는 말이 자주 들릴 정도로, DB 부하를 줄이기 위해 Redis 캐시는 표준처럼 쓰입니다.
    - **콘텐츠 전송 네트워크(CDN) 및 웹캐시:** 정적 콘텐츠(이미지, HTML, JS 파일 등)는 클라이언트 가까운 CDN 엣지 서버에 캐싱해두고 제공함으로써, 사용자 체감 속도를 높이고 원 서버 부하를 줄입니다. Nginx 등의 리버스 프록시를 이용해 **웹 서버 자체 캐시**(프록시 캐싱)를 운용하기도 합니다.
    - 예를 들어 Nginx가 특정 API 응답을 메모리에 캐시해, 동일 요청이 올 때 백엔드에 전달하지 않고 캐시된 응답을 곧바로 주는 식입니다.
- 캐시 설계 시 고려할 점으로 **만료 정책(expiration)**이 있습니다. “캐시에 올린 데이터가 **언제까지 유효한가?** 를 정해야 합니다.” TTL(Time To Live) 기반으로 5분 등 일정 시간 후 캐시를 무효화하거나, 수동으로 갱신(데이터 변경 시 캐시 삭제)하는 방식을 사용합니다. 캐시를 잘못하면 오래된 데이터로 인한 문제(정합성 문제)가 생길 수 있으므로 용도에 따라 적절한 만료 전략을 세워야 합니다.
- 실무 예시
    - 대형 포털 사이트에서 로그인 사용자 정보를 DB에서 자주 조회하는 대신 로그인 시 한 번 Redis에 저장해두고 이후 조회는 Redis에서 하는 경우가 많습니다.
    - 또한 인기 게시판 글 목록을 DB가 아닌 캐시에 갱신/조회하거나, API 응답 결과(JSON)를 통째로 캐시해 트래픽을 줄이는 테크닉도 있습니다.
- **요점은, 캐시는 속도와 비용 사이의 트레이드오프 도구이며, 적재적소에 활용하면 시스템 효율이 극대화**된다는 것입니다.

### **메시지 큐 (Message Queue)**

- **메시지 큐**는 시스템 컴포넌트 간에 비동기식 메시지 전달을 위한 **중간 버퍼** 역할을 하는 인프라입니다. 쉽게 비유하면, A라는 사람이 B에게 바로 전화를 거는 대신, **우편함**에 편지를 넣어두면 B가 나중에 꺼내보는 방식과 유사합니다.
- 기술적으로, 메시지 큐는 **송신자(Producer)가 보낸 메시지를 보관했다가 수신자(Consumer)가 꺼내 처리할 때까지** 큐(Queue) 형태로 유지합니다 . 대표적으로 **FIFO(선입선출)** 방식으로 동작하여 보낸 순서대로 메시지를 전달하며, 덕분에 **비동기 처리**를 쉽게 만들 수 있습니다 .
- 왜 메시지 큐를 쓰는가:
    - **비동기 작업 처리:** 어떤 작업들은 즉각 응답을 줄 필요 없이 나중에 처리해도 될 때가 있습니다. 예를 들어 회원 가입시 환영 이메일 보내기, 이미지 썸네일 생성 등은 메인 흐름과 분리해 **백그라운드 작업**으로 처리하는 것이 효율적입니다. 이때 메시지 큐를 사용하여 이메일 전송 요청 메시지를 큐에 넣고 바로 가입 완료 응답을 보내면, 실제 이메일 전송은 별도 워커가 큐에서 메시지를 꺼내 처리하게 할 수 있습니다. **RabbitMQ** 같은 큐를 활용하면 이런 패턴을 구현하기 용이합니다.
- **시스템 간 결합도 감소:** 주문 서비스에서 결제 서비스 호출 시 즉시 결과를 받지 않고 큐에 결제 요청 메시지를 넣어두면, 주문 서비스와 결제 서비스가 **긴밀하게 붙어있지 않아도** 업무가 진행됩니다. 메시지 큐는 **모듈 사이의 완충지대** 역할을 하여, 한쪽 시스템의 일시 지연이나 장애가 다른 쪽에 바로 전파되지 않도록 합니다 . 예를 들어 트래픽이 폭증해 주문 메시지가 쌓여도 결제 소비자가 느린대로 처리하면서 시스템 전체 다운을 피할 수 있습니다.
- **스케일링 및 병렬 처리:** 큐에 메시지를 넣어두면 이를 처리하는 **컨슈머(Consumer)**를 여러 개 두어 병렬 처리할 수 있습니다. 필요에 따라 컨슈머 인스턴스를 늘리면 쌓인 작업들을 더 빨리 소화할 수 있어 동적 확장에도 유리합니다. Kafka와 같은 **분산 로그 시스템**은 높은 처리량과 확장성을 제공하여 대용량 이벤트 스트림 처리에 활용됩니다 .
- 실무에서 메시지 큐의 활용 예시는 다양합니다. **이메일/SMS 발송**, **주문 후배송 처리**, **로그 처리**, **챗 서비스의 비동기 이벤트** 등, 즉각적 응답이 필요 없거나 시간 차를 두고 처리해도 되는 일에 큐가 쓰입니다. **Kafka**는 스트림 데이터(예: 사용자의 행동 로그를 모아 실시간 분석) 처리에 많이 쓰이고, **RabbitMQ**나 **ActiveMQ, Amazon SQS** 등은 작업 큐/이벤트 전달용으로 많이 사용됩니다.
- 설계 시 유의점은 **메시지 중복 처리**와 **메시지 유실 방지**(디스크 내구성 옵션 등)입니다.
- 큐를 도입하면 시스템 복잡도가 증가하므로, 꼭 필요한 경우에 사용하는 것이 좋습니다. 하지만 큐를 통한 비동기 아키텍처를 알아두면 확장성과 안정성을 높이는 데 큰 도움이 될 것입니다.

### **컨테이너와 쿠버네티스 (Container & Kubernetes)**

- **컨테이너 기술**은 현대 서버 배포의 표준으로 자리잡았습니다. 그 핵심은 애플리케이션과 그 환경을 **표준화된 패키지**로 묶어 어디서나 일관되게 실행할 수 있게 해주는 것입니다.
- **Docker(도커):**
    - 도커는 컨테이너화를 대중화한 기술입니다. 컨테이너는 격리된 사용자 공간에서 프로세스를 실행하여, OS는 공유하지만 마치 별도 환경인 것처럼 동작합니다.
    - 도커를 사용하면 애플리케이션 실행에 필요한 모든 것을 (코드, 런타임, 라이브러리, 설정 등) **이미지(Image)**로 만들고, 이를 기반으로 어디서든 동일한 결과가 나오는 **컨테이너**를 띄울 수 있습니다.
    - 개발자 입장에서 **“내 컴퓨터에서 되던게 서버에서 안되는”** 문제를 크게 줄여줍니다 .
    - 예를 들어 Node.js 14 버전에서 동작하는 코드를 컨테이너로 만들면, 운영 서버에도 Node.js 14 환경이 자동으로 구성되어 동일하게 실행됩니다.
    - 이러한 **환경 일관성**은 배포 오류를 줄이고, 또한 여러 프로젝트가 충돌하는 의존성을 각각 컨테이너로 격리해 해결할 수도 있습니다 .
    - **배포 용이성:** 컨테이너 이미지는 한 번 만들면 어디서나 동일하게 돌아가므로, 개발/테스트 환경에서 이미지 빌드 후 운영에 배포하는 CICD 파이프라인이 단순해집니다.
    - VM에 비해 **가볍고 빠르게 기동**되어 오토스케일 등에 유리하고, 컨테이너끼리 네트워크로 연결하거나 스토리지를 붙이는 등 **인프라 추상화** 계층도 잘 갖춰져 있습니다.
    - **실무 활용:** 개발 PC에서 도커로 전체 개발 환경을 구성(docker-compose 등)하여 “개발 환경 셋업” 시간을 줄이는 사례, 운영에 컨테이너로 배포해 서버 수 줄이고 밀도를 높인 사례 등이 많습니다. 마이크로서비스를 컨테이너로 각각 패키징하면, 하나 바꾸더라도 해당 컨테이너만 배포하면 되니 편리합니다.
- **쿠버네티스(Kubernetes):**
    - 다수의 컨테이너를 **클러스터**로 묶어 관리해주는 **컨테이너 오케스트레이션 플랫폼**입니다. 도커가 **컨테이너 실행** 자체를 담당한다면, 쿠버네티스는 **여러 대의 서버에 걸쳐 컨테이너들의 배치를 관리**하고, 서비스 디스커버리, 로드밸런싱, 자동 재시작, 스케일링 등의 상위 개념을 제공합니다.
    - 쿠버네티스를 쓰면 가능한 것들:
        - **오토스케일 및 자가치유**: 설정에 따라 특정 서비스의 컨테이너 파드를 트래픽에 맞춰 자동으로 늘리거나 줄일 수 있습니다. 또한 컨테이너/노드가 죽으면 쿠버네티스가 감지하여 자동으로 새로운 인스턴스를 올려 복구합니다. 수동 개입 없이도 **탄력적 확장**과 **안정성**을 얻는 것이죠.
        - **배포 전략**: 블루-그린 배포, 롤링업데이트 등을 쿠버네티스 객체 설정으로 손쉽게 구현합니다. 예를 들어 새로운 버전 이미지를 올릴 때 한 개씩 교체하며 트래픽을 점진적으로 넘기는 롤링 업데이트가 기본 지원됩니다.
        - **인프라 추상화 및 표준화**: 개발자는 Deployment, Service, ConfigMap 같은 쿠버네티스 리소스만 정의하면, 클러스터 내 어떤 노드(서버)에서 돌든 상관없이 서비스가 돌아갑니다. 네임스페이스로 격리하고, 서비스 디스커버리를 통해 컨테이너 IP가 바뀌어도 서비스명으로 통신 가능하게 하는 등, 분산 환경을 **한층 관리하기 쉽게** 만들어줍니다.

### 클라우드 서비스

- 클라우드 서비스는 **서버 인프라 구축과 운영을 손쉽게 만들어주는 플랫폼**으로, 다음과 같은 이유로 현대의 백엔드 개발에 필수적으로 자리 잡았습니다.
- **빠르고 쉬운 인프라 구축 및 관리**
    - 클라우드 서비스는 서버를 구매하거나 설정하지 않아도, **몇 분 만에 서버 인스턴스와 데이터베이스, 로드 밸런서** 등을 바로 구축할 수 있습니다.
    - 복잡한 설정 없이 웹 기반 인터페이스나 명령어를 통해 즉시 인프라를 생성 및 변경할 수 있어, 인프라 관리 시간을 절약합니다.
- **자동화와 운영 편의성**
    - 클라우드 서비스는 **모니터링, 로깅, 백업, 자동 스케일링** 등 운영 업무를 자동화하여, 개발자가 애플리케이션 개발에만 집중할 수 있게 합니다.
    - 특히, Auto Scaling과 Managed Database 등은 운영 비용을 줄이고, 관리 부담을 최소화하여 서비스 안정성을 높입니다.
- **확장성(Scalability)**
    - 클라우드 환경에서는 트래픽 변화에 따라 **서버 자원을 자유롭게 확장 및 축소할 수 있어**, 서비스가 빠르게 성장하거나 갑작스런 트래픽 증가에도 쉽게 대응할 수 있습니다.
    - 로드 밸런서와 컨테이너 오케스트레이션(쿠버네티스 등)을 연계하여 자동화된 수평 확장(scale-out)을 구현할 수 있습니다.
- **높은 가용성(High Availability)과 장애 대응**
    - 클라우드 서비스는 기본적으로 이중화, 다중 리전 배치, 데이터 자동 복제 등을 제공해 장애 발생 시에도 서비스 연속성을 유지할 수 있습니다.
    - 로드 밸런서와 결합하여 특정 서버에 장애가 발생해도 클라이언트가 이를 체감하지 못하게 합니다.
- **보안**
    - 클라우드 서비스 업체는 높은 수준의 보안 기능을 내장하고 있으며, 보안 패치 자동화, 접근 제어(IAM), 방화벽 설정 등 보안 관리 기능을 제공합니다.
    - TLS 종료(SSL Offloading)를 로드 밸런서에서 수행해 내부 서버를 보호하거나, 네트워크 격리 등을 손쉽게 구현 가능합니다.

### 인프라 구성도

![image.png](attachment:28c0d2e7-40d6-4b8b-a322-e74e74423277:image.png)

- 인프라 구성도는 서비스 설계 시 실제 시스템이 어떻게 구성되고 동작하는지 한눈에 파악할 수 있게 만들어 주며, 다음과 같은 이유에서 매우 중요합니다.
- **전체 시스템에 대한 명확한 이해**
    - 서비스가 어떻게 동작하는지, 클라이언트 요청이 실제 백엔드까지 어떻게 전달되는지 흐름을 시각적으로 파악할 수 있습니다.
    - 서버, DB, 캐시, 로드 밸런서 등 구성 요소의 역할과 위치를 빠르게 이해하여 구성 요소 간의 상호작용을 명확히 합니다.
- **의사소통 및 협업의 편의성**
    - 팀 내 개발자, 운영자, 기획자 등 모든 이해관계자들이 **동일한 구성도를 보며 설계와 운영에 대한 의견을 효과적으로 공유**할 수 있습니다.
    - 설계 문서만으로는 부족한 세부 사항을 빠르게 파악할 수 있어, 설계 논의나 변경사항을 공유할 때 구성도가 매우 유용합니다.
- **장애 대응 및 운영 효율화**
    - 시스템 장애 발생 시, 구성도를 통해 빠르게 **문제의 위치와 원인을 파악하고 대응**할 수 있어 장애 대응 시간이 크게 단축됩니다.
    - 또한, 확장 또는 변경 시 구성도를 기준으로 안정적이고 신속하게 계획할 수 있습니다.
- **보안과 최적화 관점에서의 분석 용이**
    - 구성도를 보면 보안 취약 지점(공개된 포트, 과도한 권한 부여 등)을 빠르게 발견하고 보완할 수 있습니다.
    - 성능 병목 지점이나 확장 가능성을 시각적으로 분석할 수 있어 시스템의 성능 최적화에도 매우 유리합니다.

---

## **서버 설계 시 놓치기 쉬운 부분: 보안, 로깅/모니터링, 장애 대응**

<aside>
🚤

서버를 설계할 때는 많은 사람들이 기능 개발이나 성능 최적화, 트래픽 처리와 같은 기술적인 요소에 집중합니다. 하지만 실무에서는 기술적인 요소 외에도 반드시 고려해야 할 영역들이 있습니다. 바로 **보안(Security)**, **로깅과 모니터링(Logging & Monitoring)**, **장애 대응 및 복구(Incident Response & Recovery)**입니다. 이 요소들은 서비스의 신뢰성과 안정성을 확보하는 데 핵심적인 역할을 하며, 실제 운영 환경에서는 없어서는 안 될 필수 설계 항목입니다.

이번 장에서는 이 세 가지 요소가 왜 중요한지, 어떤 방식으로 설계와 운영에 반영되어야 하는지를 구체적으로 설명합니다.

</aside>

### **보안(Security)은 왜 중요할까?**

보안은 단순한 기술이 아니라, 사용자와 데이터를 보호하고 서비스 신뢰를 유지하는 **운영의 핵심 축**입니다. 보안 사고는 한 번 발생하면 단순히 기술적인 문제가 아니라 회사 전체의 평판과 손실로 이어질 수 있습니다. 따라서 서버 설계 단계부터 보안 요소를 구조에 반영하는 것이 매우 중요합니다.

- **인증(Authentication)과 인가(Authorization)**는 각각의 목적과 방식이 다르므로 정확히 나눠 설계해야 합니다.
    - 인증: 사용자가 누구인지 확인하는 과정입니다. 보통 로그인 과정을 통해 수행됩니다.
    - 인가: 인증된 사용자가 어떤 작업을 수행할 수 있는지를 판단하는 과정입니다. 관리자만 접근 가능한 페이지처럼 역할 기반 권한 제어가 대표적입니다.
    - 비밀번호는 절대 평문으로 저장하지 않고 안전한 해시 함수로 암호화합니다.
    - JWT를 사용할 경우, 토큰 유효 시간 설정과 시크릿 키 관리도 중요합니다. 토큰 탈취를 방지하기 위해 토큰 재사용 방지, 로그아웃 처리 등도 고려해야 합니다.
- **데이터 보호**는 단순히 암호화뿐 아니라 데이터 흐름 전반을 안전하게 만드는 설계입니다.
    - 모든 요청/응답은 HTTPS를 통해 전송하며, TLS 버전도 최신으로 유지해야 합니다.
    - 개인정보, 결제 정보 등 민감 데이터는 DB 저장 시 암호화하고, 접근 로그를 통해 누가 조회했는지도 추적 가능하도록 해야 합니다.
- **서버 접근 제한과 네트워크 보안** 역시 실무에서 매우 중요한 부분입니다.
    - 서버 접근은 IP 화이트리스트, 키 기반 인증 등으로 통제하며, 불필요한 포트는 닫고 내부 방화벽 규칙을 정리합니다.
    - 보안 그룹 설정이나 VPC 내에서 사설 네트워크를 활용해 외부 노출을 최소화합니다.
- **DDoS 및 봇 공격 대응**도 반드시 준비되어 있어야 합니다.
    - Cloudflare, AWS Shield, WAF 등을 사용하여 유해 트래픽을 사전에 차단하거나 필터링할 수 있도록 구성합니다.
    - 요청 횟수 제한(rate limit), CAPTCHA 등의 도입도 봇 방지에 효과적입니다.

### **로깅과 모니터링은 왜 필요할까?**

시스템이 정상 작동하는지 확인하고, 문제가 발생했을 때 원인을 빠르게 찾으려면 로깅과 모니터링이 필수입니다. 단순한 출력 로그나 서버 리소스 확인을 넘어서, 실제 운영 수준의 로깅과 모니터링 설계가 필요합니다.

### **로깅(Logging): 무슨 일이 있었는지를 기록하는 행위**

- 로그인 시도, 주문 요청, 결제 실패 등 모든 주요 행위는 로그로 남겨야 합니다.
- 단순 텍스트 로그보다 **구조화된 로그(JSON)** 형식을 사용하면 검색과 분석이 훨씬 용이합니다.
- 예외나 에러 발생 시에는 스택 트레이스, 요청 파라미터, 사용자 정보 등을 함께 기록하여 디버깅 시간을 줄입니다.
- 민감한 데이터는 로그에 절대 출력하지 않도록 필터링을 거쳐야 하며, 실수로 토큰이나 비밀번호가 노출되지 않도록 사전에 설정합니다.

### **모니터링(Monitoring): 시스템 상태를 실시간으로 감시하고 예외 상황을 감지하는 체계**

- 서버의 CPU, 메모리, 디스크 사용량은 기본이고, 요청 수, 응답 속도, 에러율 등 서비스 지표도 함께 모니터링합니다.
- Prometheus, Grafana, AWS CloudWatch, DataDog 등 다양한 도구를 이용해 시각화 대시보드를 구성하면 관리가 쉬워집니다.
- 특정 임계값을 초과할 경우 Slack, 이메일, SMS 등으로 실시간 알림을 받을 수 있도록 설정합니다.
- 각종 지표를 조합하여 사용자 이탈율, DB 연결 수 증가 등 간접적인 문제도 탐지할 수 있게 만듭니다.

> 🎯 성능 최적화를 위해서도 로깅과 모니터링은 반드시 필요합니다.
> 
> - 느린 API를 찾고,
> - 리소스 사용이 급증하는 시점을 파악하고,
> - 특정 기능이 반복적으로 실패하는 패턴을 로그로 분석함으로써,
> - 시스템 구조 개선이나 캐싱 도입 등 성능 개선의 실마리를 확보할 수 있습니다.

### **장애 대응과 복구는 왜 준비해야 할까**

100% 무장애 시스템은 없습니다. 장애는 언젠가는 반드시 발생합니다. 중요한 것은 장애가 발생했을 때 얼마나 빠르고 정확하게 대응하고 복구할 수 있느냐입니다.

- **장애 대응 프로세스 정립**은 사전 준비의 핵심입니다.
    - 장애 발생 시 담당자 호출 체계, 문제 파악 절차, 커뮤니케이션 채널(Slack, Zoom 등)을 정해두어야 합니다.
    - 모든 팀원이 해당 프로세스를 이해하고 있어야 하며, 정기적으로 장애 대응 모의훈련을 실시하면 실전에 도움이 됩니다.
- **이중화와 백업 체계 구축**은 장애 확산을 막고 서비스 연속성을 보장합니다.
    - 서버, 데이터베이스, 캐시 등 핵심 요소는 이중화(Redundancy)를 통해 하나가 고장나도 시스템이 유지되도록 구성합니다.
    - 데이터는 주기적으로 백업하고, 백업 데이터로 복구 테스트를 정기적으로 진행합니다.
    - 클라우드 환경에서는 여러 가용 영역(AZ)이나 리전을 활용해 물리적 장애에도 대응할 수 있도록 구성합니다.
- **Postmortem 분석과 재발 방지**는 장애 이후의 핵심 절차입니다.
    - 장애 원인을 정확히 파악하고, 영향 범위, 대응 시간, 복구 과정 등을 문서로 기록합니다.
    - 동일 유형의 장애가 재발하지 않도록 시스템 구조나 코드에 개선을 적용합니다.
    - 작성된 Postmortem 문서는 팀 전체와 공유되어야 하며, 향후 유사 상황 발생 시 빠른 참고 자료가 됩니다.

---
 