## 과제 : 대기업 시나리오 프로젝트로 알아보는 서버 설계

<aside>
🚢

**설계, 그래서 어떻게 해야하는데요!?**

모든지 처음이 어렵습니다! 익숙한 대기업들의 프로젝트 시나리오를 준비했어요.

실무 기반 프로젝트를 통해 클린 아키텍처, DB 모델링, 동시성 처리까지 **실전 서버 설계 및 개발 능력**을 기릅니다.

</aside>

### 1. 시나리오 선택
다음의 시나리오 중 과제를 진행할 시나리오를 선택해주세요~!

============
[e-커머스 서비스](https://www.notion.so/e-2552dc3ef5148194a06df3fa1b9875aa?pvs=21)
## Description

- `e-커머스 상품 주문 서비스 시나리오 입니다.`
- 상품 주문에 필요한 메뉴 정보들을 구성하고 조회가 가능 없도록 작성하도록 합니다.
- 동시성 이슈를 고려하여 구현합니다.해야 합니다.
- 사용자는 상품을 여러개 선택해 주문할 수 있고, 미리 충전한 잔액을 이용합니다.
- 상품 주문 내역을 통해 판매량이 가장 높은 상품을 추천합니다.

## Requirements
- 아래 4가지 API 를 구현합니다.
    - 잔액 충전 / 조회 API
    - 상품 조회 API
    - 주문 / 결제 API
    - 인기 판매 상품 조회 API
- 각 기능 및 제약사항에 대해 단위 테스트를 반드시 하나 이상 작성하도록 합니다.
- 다수의 인스턴스로 어플리케이션이 동작하더라도 기능에 문제가
- 재고 관리에 문제 없도록 구현합니다

## API Specs
### 기본과제
#1 주요 잔액 충전 / 조회 API
- 결제에 사용될 금액을 충전하는 API 를 작성합니다.
- 사용자 식별자 및 충전할 금액을 받아 잔액을 충전합니다.
- 사용자 식별자를 통해 해당 사용자의 잔액을 조회합니다.


#2 기본 상품 조회 API
- 상품 정보 ( ID, 이름, 가격, 잔여수량 ) 을 조회하는 API 를 작성합니다.
- 조회시점의 상품별 잔여수량이 정확하면 좋습니다.

#3 선착순 쿠폰 기능
- 선착순 쿠폰 발급 API 및 보유 쿠폰 목록 조회 API 를 작성합니다.
- 주문 시에 유효한 할인 쿠폰을 함께 제출하면, 전체 주문금액에 대해 할인 혜택을 부여받을 수 있습니다.
    - 사용자는 선착순으로 할인 쿠폰을 발급받을 수 있습니다.

#4 주문 / 결제 API

- 사용자 식별자와 (상품 ID, 수량) 목록을 입력받아 주문하고 결제를 수행하는 API 를 작성합니다.
- 결제는 기 충전된 잔액을 기반으로 수행하며 성공할 시 잔액을 차감해야 합니다.
- 데이터 분석을 위해 결제 성공 시에 실시간으로 주문 정보를 데이터 플랫폼에 전송해야 합니다. ( 데이터 플랫폼이 어플리케이션 `외부` 라는 가정만 지켜 작업해 주시면 됩니다 
> 데이터 플랫폼으로의 전송 기능은 Mock API, Fake Module 등 다양한 방법으로 접근해 봅니다.
>
#5 **상위 상품 조회 API**

- 최근 3일간 가장 많이 팔린 상위 5개 상품 정보를 제공하는 API 를 작성합니다.
- 통계 정보를 다루기 위한 기술적 고민을 충분히 해보도록 합니다.

<aside>
💡 **KEY POINT**

</aside>

- 동시에 여러 주문이 들어올 경우, 유저의 보유 잔고에 대한 처리가 정확해야 합니다.
- 각 상품의 재고 관리가 정상적으로 이루어져 잘못된 주문이 발생하지 않도록 해야 합니다.

============
[콘서트 예약 서비스](https://www.notion.so/2552dc3ef514815e9fcac2a75d1af2e3?pvs=21)
## Description

- **`콘서트 예약 서비스 시나리오 입니다.`**
- 대기열 시스템을 구축하고, 예약 서비스는 작업가능한 유저만 수행할 수 있도록 해야합니다.
- 사용자는 좌석예약 시에 미리 충전한 잔액을 이용합니다.
- 좌석 예약 요청시에, 결제가 이루어지지 않더라도 일정 시간동안 다른 유저가 해당 좌석에 접근할 수 없도록 합니다.


## Requirements

- 아래 5가지 API 를 구현합니다.
    - 유저 토큰 발급 API
    - 예약 가능 날짜 / 좌석 API
    - 좌석 예약 요청 API
    - 잔액 충전 / 조회 API
    - 결제 API
- 각 기능 및 제약사항에 대해 단위 테스트를 반드시 하나 이상 작성하도록 합니다.
- 다수의 인스턴스로 어플리케이션이 동작하더라도 기능에 문제가 없도록 작성하도록 합니다.
- 동시성 이슈를 고려하여 구현합니다.
- 대기열 개념을 고려해 구현합니다.

## API Specs
*`주요` 유저 대기열 토큰 기능**
- 서비스를 이용할 토큰을 발급받는 API를 작성합니다.
- 토큰은 유저의 UUID 와 해당 유저의 대기열을 관리할 수 있는 정보 ( 대기 순서 or 잔여 시간 등 ) 를 포함합니다.
- 이후 모든 API 는 위 토큰을 이용해 대기열 검증을 통과해야 이용 가능합니다.
> 기본적으로 폴링으로 본인의 대기열을 확인한다고 가정하며, 다른 방안 또한 고려해보고 구현해 볼 수 있습니다.
>
**예약 가능 날짜 / 좌석 API**
- 예약가능한 날짜와 해당 날짜의 좌석을 조회하는 API 를 각각 작성합니다.
- 예약 가능한 날짜 목록을 조회할 수 있습니다.
- 날짜 정보를 입력받아 예약가능한 좌석정보를 조회할 수 있습니다.
> 좌석 정보는 1 ~ 50 까지의 좌석번호로 관리됩니다.
> 

**좌석 예약 요청 API**
- 날짜와 좌석 정보를 입력받아 좌석을 예약 처리하는 API 를 작성합니다.
- 좌석 예약과 동시에 해당 좌석은 그 유저에게 약 5분간 임시 배정됩니다. ( 시간은 정책에 따라 자율적으로 정의합니다. )
- 만약 배정 시간 내에 결제가 완료되지 않는다면 좌석에 대한 임시 배정은 해제되어야 하며 다른 사용자는 예약할 수 없어야 한다.

**잔액 충전 / 조회 API**
- 결제에 사용될 금액을 API 를 통해 충전하는 API 를 작성합니다.
- 사용자 식별자 및 충전할 금액을 받아 잔액을 충전합니다.
- 사용자 식별자를 통해 해당 사용자의 잔액을 조회합니다.

**결제 API**
- 결제 처리하고 결제 내역을 생성하는 API 를 작성합니다.
- 결제가 완료되면 해당 좌석의 소유권을 유저에게 배정하고 대기열 토큰을 만료시킵니다.


심화 과제
**대기열 고도화**

- 다양한 전략을 통해 합리적으로 대기열을 제공할 방법을 고안합니다.
- e.g. 특정 시간 동안 N 명에게만 권한을 부여한다.
- e.g. 한번에 활성화된 최대 유저를 N 으로 유지한다

- 유저간 대기열을 요청 순서대로 정확하게 제공할 방법을 고민해 봅니다.
- 동시에 여러 사용자가 예약 요청을 했을 때, 좌석이 중복으로 배정 가능하지 않도록 합니다.


###

### **2. 개발 환경 준비**

- **Architecture**
    - Testable Business logics
    - Layered Architecture Based
    - (+) Clean / Hexagonal Architecture
- **DB ORM**
    - JPA / MyBatis
    - TypeORM / Prizma
- **Test**
    - JUnit + AssertJ
    - Jest / Mocha

**Template ( + testcontainers )**


### **3. 시나리오 분석 및 작업 계획**

########################## `필수 과제 - 분석`

- **원하는 시나리오 선정을 해주세요.**
- 선정한 시나리오의 아래 3가지 서버 설계 문서를 작성합니다.
    - API 명세서
    - ERD
    - 인프라 구성도
    (작성한 인프라 구성도에 있는 항목들을 간단하게 기술해주세요.)
- 주의할점은 다른 프로젝트 구성원이 봤을 때 이해가 되어야 한다는 점을 고려해주세요.
- 문서는 README 또는 docs 디렉토리 내 .md 파일로 작성할 수 있습니다.
    - README에는 상대 경로 링크만 걸어두는 방식이 추천됩니다

############################ **`(선택)심화 과제 - 실행`**

- 선정한 시나리오의  아래 2가지 문서 서버 설계 문서 작성합니다.
    - 시퀀스 다이어그램
    - 마일 스톤
- 비즈니스 로직 기능 구현을 합니다.

## **항해 플러스 서버 구축 프로젝트 : 과제 추가 자료**

### **Milestone**
### **Milestone 이란 무엇인가?**
- 프로젝트를 단계로 나누고, 각각을 주요 이벤트 및 단위 작업으로 지정해 진행 단계를 표시하고 프로젝트를 완성해 나가는 작업을 말합니다.

### **Milestone 이 중요한 이유**
- 프로젝트의 **구체적인 목표 정의**
- 프로젝트의 **주요 리소스 관리**
- 프로젝트의 **진행상황 모니터링**
- 프로젝트의 **기간 조정** 및 **내재된 문제 식별**

### 문제 정의 및 요구사항 분석
### 문제 정의
- 해결하고자 하는 것이 무엇인지 명확히 설명할 수 있어야 함
- 문제에 대한 추상적인 접근을 할 수 있어야 함
<aside>
🔥

문제를 뾰족하게 바라보는 연습을 많이 해야 한다.
</aside>
### 요구사항 분석
- 기능적 요구사항 - 어떤 기능을 제공할 수 있어야 하는가?
- 비기능적 요구사항 - 성능, 확장성, 보안 관련한 추가적인 고려사항들을 고려할 수 있어야 한다.
<aside>
🔋

범람하는 요구사항을 적절하게 분류, 정리할 수 있어야 한다.
</aside>



### 분석을 설계로 풀어내기
### 시퀀스 다이어그램
- **시스템 내에서 객체(또는 서비스)들이 어떻게 상호 작용하는지를 시간 순서대로 표현**하는 다이어그램
- 주로 **API 호출 흐름, 이벤트 처리 방식, 데이터 흐름을 설명할 때 사용**
<aside>
📝

**Example**
✅ 사용자가 로그인하는 과정
✅ 클라이언트가 API를 호출하고 서버에서 데이터를 반환하는 과정
✅ 비즈니스 프로세스에서 특정 요청이 처리되는 흐름
</aside>

### 클래스 다이어그램
- **시스템에서 사용되는 객체(Class)들의 구조와 관계를 표현하는 다이어그램**
- 주로 **도메인 모델링이나 엔티티 설계**에서 사용
<aside>
📝

**Example**
✅ 도메인 모델링 (예: 주문, 상품, 사용자 관계 정의)
✅ 엔티티 설계 (예: JPA Entity 간 관계 정의)
✅ 클래스 간 상속 및 의존성 표현
</aside>



### ERD ( Entity - Relationship Diagram )
- **데이터베이스의 테이블 간 관계를 표현하는 다이어그램**
- DB 설계 단계에서 **각 테이블(엔티티) 간의 관계를 시각적으로 정리하는 데 사용**

<aside>
📝

**Example**
✅ DB 스키마 설계 (테이블 정의 및 관계 설정)
✅ ORM (JPA, Hibernate) 모델링
✅ SQL JOIN 최적화 분석

</aside>


### 상태 다이어그램
- **객체 또는 프로세스가 특정 이벤트에 따라 상태가 어떻게 변하는지를 표현하는 다이어그램**
- 특정 기능의 **상태 전이(Transitions)를 설명할 때 사용**

<aside>
📝

**Usecase**
✅ 주문(Order) 상태 전이 (결제 대기 → 결제 완료 → 배송 중)
✅ 사용자 로그인 상태 (미인증 → 로그인 → 로그아웃)
✅ 서킷 브레이커 상태 (Closed → Open → Half-Open)
</aside>



API Spec Documentation
우리는 적절한 API 명세 문서를 노출하고 MockAPI 를 제공해 생산성을 증대시켜야 합니다.
API 명세
Endpoint - API 의 URL 및 기능을 설명할 수 있는 적절한 HTTP Method
Request - Param, Query, Body 등 API 호출 시 전달되어야 할 매개변수 및 데이터
Response - API 의 응답 코드, 데이터 등에 대한 명세 및 적절한 예제
Error - API 호출 중 발생할 수 있는 예외 케이스에 대해 명시
Authorization - 필요한 인증, 권한에 대해서도 명시
Mock API 로 생산성 극대화
API Spec 을 정했다면, 최대한 빠르게 Mock API 를 작성해 배포해야 함
우리는 혼자 일하는 게 아니다!
API Spec 이 정해졌다면, 그 API 를 활용하는 다른 동료 ( 프론트엔드, 다른 백엔드 팀 등 ) 이 Dummy 데이터로 시뮬레이션을 할 수 있어야 함.
curl, http (intellij), postman 등으로 API 시뮬레이션을 할 수 있어야 합니다.
API 문서만 보고도 이해할 수 있게!
OAS (Open API Specification) , AsyncAPI (Pub/Sub API Describe) , ..
API Documentation
Open API Specification  - json, yaml 기반의 REST API 문서화 표준
Swagger UI - OAS 를 Web UI 로 표현 가능하도록 지원

→ 라이브러리를 통해 프레임워크의 API 문서 생성 자동화 기능 지원
→ API 명세 및 API TEST 제공을 통해 보기 쉬운 문서 제공
→ API 버전 관리, 통합 API 문서 제공 등의 문서 관리 기능 제공
// spring
implementation("org.springdoc:springdoc-openapi-starter-webmvc-ui:2.0.0")

// nest
npx nestia swagger









